#+TITLE: Python Programming Notes
#+AUTHOR: Alex

* Contents                                                              :TOC:
- [[#packages-and-modules][Packages and Modules]]
  - [[#introduction][Introduction]]
  - [[#files-and-directories][Files and Directories]]
  - [[#package-initialisation][Package Initialisation]]
  - [[#demonstration][Demonstration]]
  - [[#using-__all__][Using =__all__=]]
- [[#functions-and-procedural-programming][Functions and Procedural Programming]]
- [[#object-orientation][Object Orientation]]
  - [[#classes-as-objects][Classes as Objects]]
  - [[#private-and-public-attributes][Private and Public attributes]]
  - [[#inheritance-and-polymorphism][Inheritance and Polymorphism]]

* Packages and Modules
** Introduction

Python extends its high level of abstraction over the filesystem.

- In python a file or folder is seen as a module
- Packages are modules which may contain other modules.
- Packages are often seen as directories containing a =__init__.py=  file.
- The =__init__.py= file is largely not needed in later versions of python, but is widely used and more useful than not.

#+begin_src 
 .
 |--package_1/
 |  |--__init.py__
 |  `--module_1.py
 |
 |--package_2/
 |  `--module_2.py
 |
 |--test.py

#+end_src

- Given the file tree shown above, =module_1.py=, =module_2.py= and =test.py= are single-file modules and have the standard attributes of a module as well as anythig else we define in that module.
- We can view the =__file__=  attribute of objects of type 'module'. This variable will return the path of the file for the imported module if it exists. 
- If that module is a python file, the =__file__= value will be the full path to that file.
- If the module is a filesystem directory, the =__file__= attribute will be =__init__.py= if that file exists, else it will be ~None~.
- If the module is a filesystem directory, it will also have the =__path__= atribute, not found on python file modules.

** Files and Directories

In the abscence of a =__init__.py= file, the directory is imported as a package (module), but it will not have all the attributes we might expect.
A quick look at the list of attributes will reveal that it has no custom attributes.
Notably, the nested modules are not shown as attributes.
So for any module, file or directory, custom attributes are determined in the file specified: =__file__=.

#+begin_src python

from pprint import pprint
import package_2

pprint(locals()) # This will show you that only package_2 is bound to a symbol in the current environment.

#This code block will print the type of the module ('module'); all of its attributes; the file associated with it (if any) and the path object for it.
print(type(package2)) #module
print(dir(package2)) # list all the attributes of the package, in this case only default attributes.
print(package2.__file__) #None
print(package2.__path__) #present because this is recognised as a package.

#+end_src

Because the package above has no attributes we cannot use dot syntax to access any nested modules.
We can, however, use this technique to structure files.
Supposing we want to import =module_2.py=, we can do that without the use of a =__init__.py= using two methods.

1. =from= syntax

#+begin_src python

from pprint import pprint
from package_2 import module_2 

pprint(locals()) # Will show that module_2 is bound to a symbol in current scope.

#+end_src

In the example above we have used directories to organise our code, but we have not added any behaviour or attributes to our package.
This is entirely permitted and you may choose to organise your code like this.

2. 'dot' syntax
   
#+begin_src python

from pprint import pprint
import package_2.module_2 

pprint(locals()) # Will show that only package_2 is bound to a symbol in current scope.
pprint(dir(package_2)) # This type of import will add the module_2 attribute to the package_2 module in the current scope.

#+end_src

In this example we have used the dot qualifier to bind a module to the package symbol. 
Notice that we can use this syntax to navigate the file system in the import statement itself.
This means we can now use dot operations on the imported package to access its member modules.
In practice we will use the =__init__.py= file to make this process easier, especially valuable for importing nested packages and multiple other modules.

** Package Initialisation

As discussed above =__init__.py= is a powerful intialisation tool for our packages. 
With this file, we can effectively 'run code' when a package - or more literally, a directory - gets imported.
This allows us to start transforming an organisational structure for files into a more interactive python code heirachy.

The obvious problem with =package_2/= is that nested modules are not accesible from the imported symbol.
We have seen how we can access that code, but it can be cleaner to use a =__init__.py= file to import nested modules for us.
If we do this, we should be able to use dot qualifiers on our package symbols to get at the modules and code inside, without the need to manually import that code.

Here is some example code we could put inside the =__init__.py= for =package_1=.

#+begin_src python

# This code could be in package_1/__init__.py

import package_1.module_1

#+end_src

Alternatively, we could use a relative import to simplify this code:

#+begin_src python

from . import module_1

#+end_src

This is a very useful file. It means that whenever the outer package is imported, nested modules get bound to the package symbol.
With this code in place, this code would work in =test.py=:

#+begin_src python

import package_1

print(dir(package_1)) # This will show that the nested module is bound to a symbol under package_1.
print(dir(package_1.module_1)) # This will print the attributes of the imported module.

# Supposing that there is a function: function_1 in module_1, we caould use it like this:

package_1.module_1.function_1()

#+end_src

So you can see how the use of a =__init__.py= can create a hierachical code structure, navigated by dot qualifier syntax.

** Demonstration

This python code uses all of the techniques documented above to use code nested in other modules.

- I used the =in= operator to check if a string was in an iterable series.
- In this case we were looking for a symbol in a list of symbols in the current scope.
- A =True= result means that the symbol was in the local scope.

#+begin_src python :tangle ./sample_code/packages_and_modules/test.py :result output

print("Import package_1. This has a '__init__.py' so additional attributes will be bound to the symbol.")
import package_1
print("Here is proof that 'package_1' was imported:")
print(("package_1" in locals()))
print("Here is proof that the nested module is now an attribute of package_1: ")
print(("module_1" in dir(package_1)))
print("functions within the nested modules can be used: ")
package_1.module_1.function_1()
print("\n")

print("Import package_2. This does not have a '__init__.py' so nested modules will not automatically be bound as modules.")
import package_2
print("Here is proof that 'package_2' was imported:")
print(("package_2" in locals()))
print("Here is proof that the nested module is not an attribute of package_2: ")
print(("module_2" in dir(package_2)))

print("\n")

print("It is still possible to use the code in module_2.")
import package_2.module_2

print("Here is proof that the nested module is now an attribute of package_2: ")
print(("module_2" in dir(package_2)))

print("Now we can use that code: ")

package_2.module_2.function_2()

#+end_src

This is the output of that code:

#+begin_src 

Import package_1. This has a '__init__.py' so additional attributes will be bound to the symbol.
Here is proof that 'package_1' was imported:
True
Here is proof that the nested module is now an attribute of package_1:
True
functions within the nested modules can be used:
This is a function from module_1


Import package_2. This does not have a '__init__.py' so nested modules will not automatically be bound as modules.
Here is proof that 'package_2' was imported:
True
Here is proof that the nested module is not an attribute of package_2:
False


It is still possible to use the code in module_2.
Here is proof that the nested module is now an attribute of package_2:
True
Now we can use that code:
This is a function from module_2

#+end_src

** Using =__all__=
* Functions and Procedural Programming
* Object Orientation

Python is an object orientated language, so there is lots to say here.
The basic idea of object orientations is that code and data are grouped together, creating objects.
Objects are often instantiated from classes, which are also objects.
Python extends object orientation as far as files and directories, which become *modules*.

** Classes as Objects
*** Overview

Classes we define inherit from python's inbuilt 'object' superclass.
This is were the default methods and attributes of a class come from.

Many types have a built-in attribute: =__mro__=, which can be seen with the =mro()= function.
This attribute shows the derivation of the class, ending in 'object'.

Another useful python function is =dir()=. 
This function shows all the useful attributes and methods of an object.

#+begin_src python :tangle ./sample_code/simple_class.py :results output

class test(object):

    def __init__(self):

        self.name = "test_class"
     
instance = test()
print(dir(instance))
print(test.__mro__)
print(test.mro())

#+end_src

Below you can see the results.
Notice that the list of attributes of the class includes the =name= attribute which we added.
You can also the inheritance from =object= which has taken place.

#+RESULTS:
: ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name']
: (<class '__main__.test'>, <class 'object'>)
: [<class '__main__.test'>, <class 'object'>]

*** Class Methods

- In python we often handle instance attributes and methods.
- In order to manipulate these attributes, the =self= arguement is supplied to our methods.

There also exists the mechanism for manipulating classes themselves.

- Any manipulation of class attributes is reflected across any instances of that class.
- It is also possible to modify and use class attributes by qualifying the class name, as you would with an instance object.

#+begin_src python :tangle ./sample_code/class_method.py :results output

class Person:
    
    number = 0 

    @classmethod
    def issue_id(cls):

        cls.number += 1
        return cls.number

    @classmethod
    def return_population(cls):

        return cls.number

    def __init__(self, name):

        self._name = name
        self._id = Person.issue_id()

def main():

    print(f"Current population: {Person.return_population()}")
    person_1 = Person("Alex")
    person_2 = Person("John")
    print(f"person_1 id: {person_1._id}")
    print(f"person_2 id: {person_2._id}")
    print(f"Current population: {Person.return_population()}")

if __name__ == "__main__":

    main()

#+end_src

The result of this code is this:

#+RESULTS:
: Current population: 0
: person_1 id: 1
: person_2 id: 2
: Current population: 2

Notice that changes to the class attribute are reflected by both instances, they are assigned the next id number.

*** Static Methods

- Static methods are associated with a class, however they do not take a class attribute.
- This technique is useful for grouping functionality under one symbol, without the need for a seperate module.
- This program groups some mathematical operations under a calculator symbol.
- No instantiation is needed to use these methods.

In order to create these methods, use the =@staticmethod= decorator.
Here is some example code:

#+begin_src python :tangle ./sample_code/static_method.py :results output

class calculator:

    @staticmethod
    def add(x, y):

        return x + y

    @staticmethod
    def subtract(x, y):

        return x - y

    @staticmethod
    def multiply(x, y):

        return x * y

    @staticmethod
    def divide(x, y):

        return x / y


def main():

    # Without instantiation

    calculator.add(1, 2)
    print(calculator.add(1, 2))
    print(calculator.subtract(2, 1))
    print(calculator.multiply(2, 3))
    print(calculator.divide(12, 3))

if __name__ == "__main__":

    main()

#+end_src

Here are the results from the calculator:

#+RESULTS:
: 3
: 1
: 6
: 4.0

** Private and Public attributes
** Inheritance and Polymorphism
*** Multi-Level Inheritance

You can use the =abc= package to create truly abstract classes which offer suggested templates for other classes to follow.

#+begin_src python :tangle ./sample_code/polymorphism.py

import abc

class Animal(abc.ABC):

    @abc.abstractmethod
    def go_swimming(self):
        pass

    @abc.abstractmethod
    def go_flying(self):
        pass

    @abc.abstractmethod
    def make_noise(self):
        pass

#+end_src

Then we can create a class wich 'inherits from the 'abstract base class'.
We program in behaviours for all the abstract methods.

#+begin_src python :tangle ./sample_code/polymorphism.py

class Bird(Animal):

    def go_swimming(self):
        
        print("usually birds dont't go swimming")

    def go_flying(self):

        print("I am a bird so I can go flying")

    def make_noise(self):

        print(f"I am a bird and my name is {self._name}.")
#+end_src

We are not limited to any number of levels of inheritance.
These classes inherit from the previously defined =Bird= class.
While the superclass implemented behaviours for every signature of the abstract class, these classes are only =overloading= some of the inherited behaviour.

#+begin_src python :tangle ./sample_code/polymorphism.py

class Duck(Bird):

    def __init__(self, name):

        self._name = name

    def go_swimming(self):

        Bird.go_swimming(self)
        print("But I am a duck and I can go swimming")

class Penguin(Bird):

    def __init__(self, name):

        self._name = name


    def go_flying(self):

        Bird.go_flying(self)
        print("Because I am a penguin I cannot fly.")

#+end_src

This is also a polymorphic technique because a common interface has been built for our various objects. 
In the functions below, a constant method is applied to an object and the result differs depending on the object passed in.
In this paradigm, the type of the object determines the outcome when the same operation is applied. 
 
#+begin_src python :tangle ./sample_code/polymorphism.py

def test_noise(animal):
    
    animal.make_noise()

def test_swimming(animal):

    animal.go_swimming()

def test_flying(animal):

    animal.go_flying()

#+end_src

And finally putting it all together.

#+begin_src python :tangle ./sample_code/polymorphism.py
def main():

    penguin_1 = Penguin("penguin")
    duck_1 = Duck("alexander")

    test_noise(penguin_1)
    test_noise(duck_1)
    print("\n")
    test_swimming(penguin_1)
    test_swimming(duck_1)
    print("\n")
    test_flying(penguin_1)
    test_flying(duck_1)
    print("\n")

if __name__ == "__main__":

    main()

#+end_src

*** Multi-Derived Classes

We saw above how you can inherit successively, adding functionality and specificity with each level. 
It is also possible for a class to inherit details from who classes simultaneously.

Here is some code including two base classes:

#+begin_src python :tangle ./sample_code/multiple_inheritance.py :results output

class Base_class_1:

    def message_1(self):

        return "this message is from base class 1"

class Base_class_2:

    def message_2(self):

        return "this message is from base class 2"

class Multi_derived_class(Base_class_1, Base_class_2):

    pass

def main():

    instance = Multi_derived_class()

    print(instance.message_1())
    print(instance.message_2())

if __name__ == "__main__":

    main()

#+end_src

You can see that our derived class inherits both the =message_1= and =message_2= methods.

#+RESULTS:
: this message is from base class 1
: this message is from base class 2
